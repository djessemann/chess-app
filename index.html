<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chess</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight: rgba(255, 255, 0, 0.4);
            --possible-move: rgba(0, 0, 0, 0.1);
            --last-move: rgba(155, 199, 0, 0.41);
            --check: rgba(255, 0, 0, 0.5);
            --bg: #312e2b;
            --card-bg: #272522;
            --text: #fff;
            --text-muted: #9e9e9e;
            --accent: #81b64c;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 16px;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 480px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
        }

        h1 {
            font-size: 28px;
            font-weight: 300;
            letter-spacing: 4px;
            text-transform: uppercase;
            color: var(--text);
        }

        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 12px 16px;
            background: var(--card-bg);
            border-radius: 8px;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .player-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #fff;
            border: 2px solid #666;
        }

        .player-indicator.black {
            background: #000;
        }

        .player-indicator.active {
            box-shadow: 0 0 0 3px var(--accent);
        }

        .status-text {
            font-size: 14px;
            color: var(--text-muted);
        }

        .board-container {
            position: relative;
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
        }

        .square {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
        }

        .square.light {
            background: var(--light-square);
        }

        .square.dark {
            background: var(--dark-square);
        }

        .square.selected {
            background: var(--highlight);
        }

        .square.last-move {
            background: var(--last-move);
        }

        .square.check {
            background: var(--check);
        }

        .square.possible-move::after {
            content: '';
            position: absolute;
            width: 30%;
            height: 30%;
            background: var(--possible-move);
            border-radius: 50%;
        }

        .square.possible-capture::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 5px solid var(--possible-move);
            border-radius: 50%;
            box-sizing: border-box;
        }

        .piece {
            font-size: min(10vw, 42px);
            line-height: 1;
            pointer-events: none;
            filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.3));
            z-index: 1;
        }

        .coordinate {
            position: absolute;
            font-size: 10px;
            font-weight: 600;
            pointer-events: none;
        }

        .coordinate.file {
            bottom: 2px;
            right: 4px;
        }

        .coordinate.rank {
            top: 2px;
            left: 4px;
        }

        .square.light .coordinate {
            color: var(--dark-square);
        }

        .square.dark .coordinate {
            color: var(--light-square);
        }

        .controls {
            display: flex;
            gap: 8px;
            width: 100%;
            flex-wrap: wrap;
            justify-content: center;
        }

        button {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--card-bg);
            color: var(--text);
        }

        button:hover {
            background: #3a3733;
        }

        button:active {
            transform: scale(0.98);
        }

        button.primary {
            background: var(--accent);
            color: #fff;
        }

        button.primary:hover {
            background: #6fa33e;
        }

        .difficulty-selector {
            display: flex;
            gap: 4px;
            background: var(--card-bg);
            padding: 4px;
            border-radius: 8px;
        }

        .difficulty-btn {
            padding: 10px 16px;
            font-size: 13px;
            border-radius: 6px;
            background: transparent;
        }

        .difficulty-btn.active {
            background: var(--accent);
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--card-bg);
            padding: 32px;
            border-radius: 16px;
            text-align: center;
            max-width: 320px;
            transform: scale(0.9);
            transition: transform 0.3s;
        }

        .modal-overlay.show .modal {
            transform: scale(1);
        }

        .modal h2 {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .modal p {
            color: var(--text-muted);
            margin-bottom: 24px;
        }

        .promotion-modal .pieces {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-bottom: 16px;
        }

        .promotion-piece {
            width: 60px;
            height: 60px;
            font-size: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--light-square);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .promotion-piece:hover {
            transform: scale(1.1);
        }

        .thinking {
            display: none;
            align-items: center;
            gap: 8px;
            color: var(--text-muted);
            font-size: 14px;
        }

        .thinking.show {
            display: flex;
        }

        .thinking-dots {
            display: flex;
            gap: 4px;
        }

        .thinking-dots span {
            width: 6px;
            height: 6px;
            background: var(--accent);
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .thinking-dots span:nth-child(1) { animation-delay: -0.32s; }
        .thinking-dots span:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% { transform: scale(0); }
            40% { transform: scale(1); }
        }

        .captured-pieces {
            display: flex;
            gap: 2px;
            min-height: 24px;
            flex-wrap: wrap;
            font-size: 18px;
            opacity: 0.7;
        }

        @media (max-width: 400px) {
            .container {
                gap: 12px;
            }

            h1 {
                font-size: 22px;
            }

            .piece {
                font-size: 9vw;
            }

            button {
                padding: 10px 14px;
                font-size: 13px;
            }

            .difficulty-btn {
                padding: 8px 12px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Chess</h1>

        <div class="status-bar">
            <div class="player-info">
                <div class="player-indicator black" id="blackIndicator"></div>
                <span class="captured-pieces" id="whiteCaptured"></span>
            </div>
            <div class="thinking" id="thinking">
                <span>Thinking</span>
                <div class="thinking-dots">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div class="status-text" id="statusText">Your turn</div>
        </div>

        <div class="board-container">
            <div class="board" id="board"></div>
        </div>

        <div class="status-bar">
            <div class="player-info">
                <div class="player-indicator active" id="whiteIndicator"></div>
                <span class="captured-pieces" id="blackCaptured"></span>
            </div>
            <div class="difficulty-selector">
                <button class="difficulty-btn active" data-difficulty="easy">Easy</button>
                <button class="difficulty-btn" data-difficulty="medium">Medium</button>
                <button class="difficulty-btn" data-difficulty="hard">Hard</button>
            </div>
        </div>

        <div class="controls">
            <button id="undoBtn">Undo</button>
            <button id="newGameBtn" class="primary">New Game</button>
        </div>
    </div>

    <div class="modal-overlay" id="gameOverModal">
        <div class="modal">
            <h2 id="gameOverTitle">Game Over</h2>
            <p id="gameOverMessage">Checkmate!</p>
            <button class="primary" id="playAgainBtn">Play Again</button>
        </div>
    </div>

    <div class="modal-overlay promotion-modal" id="promotionModal">
        <div class="modal">
            <h2>Promote Pawn</h2>
            <div class="pieces" id="promotionPieces"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <script>
        // Chess Game Implementation
        const PIECES = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        const PIECE_VALUES = {
            'p': 100, 'n': 320, 'b': 330, 'r': 500, 'q': 900, 'k': 20000
        };

        // Piece-square tables for positional evaluation
        const PST = {
            'p': [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ],
            'n': [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ],
            'b': [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10, 10, 10, 10, 10, 10, 10,-10],
                [-10,  5,  0,  0,  0,  0,  5,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ],
            'r': [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5, 10, 10, 10, 10, 10, 10,  5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ],
            'q': [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [-5,  0,  5,  5,  5,  5,  0, -5],
                [0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ],
            'k': [
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [20, 20,  0,  0,  0,  0, 20, 20],
                [20, 30, 10,  0,  0, 10, 30, 20]
            ]
        };

        class ChessGame {
            constructor() {
                this.game = new Chess();
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.lastMove = null;
                this.difficulty = 'easy';
                this.isThinking = false;
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.pendingPromotion = null;

                this.initBoard();
                this.initControls();
                this.render();
            }

            initBoard() {
                const board = document.getElementById('board');
                board.innerHTML = '';

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const square = document.createElement('div');
                        const isLight = (row + col) % 2 === 0;
                        const file = String.fromCharCode(97 + col);
                        const rank = 8 - row;
                        const squareName = file + rank;

                        square.className = `square ${isLight ? 'light' : 'dark'}`;
                        square.dataset.square = squareName;

                        // Add coordinates
                        if (col === 0) {
                            const rankCoord = document.createElement('span');
                            rankCoord.className = 'coordinate rank';
                            rankCoord.textContent = rank;
                            square.appendChild(rankCoord);
                        }
                        if (row === 7) {
                            const fileCoord = document.createElement('span');
                            fileCoord.className = 'coordinate file';
                            fileCoord.textContent = file;
                            square.appendChild(fileCoord);
                        }

                        square.addEventListener('click', () => this.handleSquareClick(squareName));
                        board.appendChild(square);
                    }
                }
            }

            initControls() {
                document.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.difficulty-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.difficulty = btn.dataset.difficulty;
                    });
                });

                document.getElementById('newGameBtn').addEventListener('click', () => this.newGame());
                document.getElementById('undoBtn').addEventListener('click', () => this.undoMove());
                document.getElementById('playAgainBtn').addEventListener('click', () => {
                    this.hideModal('gameOverModal');
                    this.newGame();
                });
            }

            handleSquareClick(square) {
                if (this.isThinking || this.game.turn() !== 'w') return;

                const piece = this.game.get(square);

                if (this.selectedSquare) {
                    // Try to make a move
                    const move = this.possibleMoves.find(m => m.to === square);
                    if (move) {
                        if (move.flags.includes('p')) {
                            // Pawn promotion
                            this.pendingPromotion = { from: this.selectedSquare, to: square };
                            this.showPromotionModal();
                        } else {
                            this.makeMove(this.selectedSquare, square);
                        }
                    } else if (piece && piece.color === 'w') {
                        // Select different piece
                        this.selectSquare(square);
                    } else {
                        this.clearSelection();
                    }
                } else if (piece && piece.color === 'w') {
                    this.selectSquare(square);
                }
            }

            selectSquare(square) {
                this.selectedSquare = square;
                this.possibleMoves = this.game.moves({ square, verbose: true });
                this.render();
            }

            clearSelection() {
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.render();
            }

            makeMove(from, to, promotion = null) {
                const move = this.game.move({ from, to, promotion });
                if (move) {
                    this.lastMove = { from, to };
                    this.moveHistory.push(move);

                    if (move.captured) {
                        const capturedPiece = move.color === 'w' ? move.captured : move.captured.toUpperCase();
                        if (move.color === 'w') {
                            this.capturedPieces.white.push(capturedPiece);
                        } else {
                            this.capturedPieces.black.push(capturedPiece);
                        }
                    }

                    this.clearSelection();
                    this.checkGameOver();

                    if (!this.game.game_over() && this.game.turn() === 'b') {
                        this.computerMove();
                    }
                }
            }

            showPromotionModal() {
                const modal = document.getElementById('promotionModal');
                const piecesDiv = document.getElementById('promotionPieces');
                piecesDiv.innerHTML = '';

                ['q', 'r', 'b', 'n'].forEach(piece => {
                    const btn = document.createElement('div');
                    btn.className = 'promotion-piece';
                    btn.textContent = PIECES[piece.toUpperCase()];
                    btn.addEventListener('click', () => {
                        this.hideModal('promotionModal');
                        this.makeMove(this.pendingPromotion.from, this.pendingPromotion.to, piece);
                        this.pendingPromotion = null;
                    });
                    piecesDiv.appendChild(btn);
                });

                modal.classList.add('show');
            }

            hideModal(id) {
                document.getElementById(id).classList.remove('show');
            }

            async computerMove() {
                this.isThinking = true;
                document.getElementById('thinking').classList.add('show');
                this.updateStatus();

                // Small delay for UX
                await new Promise(r => setTimeout(r, 300));

                let move;
                switch (this.difficulty) {
                    case 'easy':
                        move = this.getRandomMove();
                        break;
                    case 'medium':
                        move = this.getBestMove(2);
                        break;
                    case 'hard':
                        move = this.getBestMove(4);
                        break;
                }

                if (move) {
                    this.game.move(move);
                    this.lastMove = { from: move.from, to: move.to };
                    this.moveHistory.push(move);

                    if (move.captured) {
                        this.capturedPieces.black.push(move.captured.toUpperCase());
                    }
                }

                this.isThinking = false;
                document.getElementById('thinking').classList.remove('show');
                this.render();
                this.checkGameOver();
            }

            getRandomMove() {
                const moves = this.game.moves({ verbose: true });
                // Prefer captures and checks for slightly smarter play
                const captures = moves.filter(m => m.captured);
                const checks = moves.filter(m => {
                    this.game.move(m);
                    const isCheck = this.game.in_check();
                    this.game.undo();
                    return isCheck;
                });

                if (Math.random() < 0.3 && captures.length > 0) {
                    return captures[Math.floor(Math.random() * captures.length)];
                }
                if (Math.random() < 0.2 && checks.length > 0) {
                    return checks[Math.floor(Math.random() * checks.length)];
                }
                return moves[Math.floor(Math.random() * moves.length)];
            }

            getBestMove(depth) {
                const moves = this.game.moves({ verbose: true });
                let bestMove = moves[0];
                let bestValue = -Infinity;

                // Move ordering for better alpha-beta pruning
                moves.sort((a, b) => {
                    let scoreA = 0, scoreB = 0;
                    if (a.captured) scoreA += PIECE_VALUES[a.captured] - PIECE_VALUES[a.piece] / 10;
                    if (b.captured) scoreB += PIECE_VALUES[b.captured] - PIECE_VALUES[b.piece] / 10;
                    if (a.promotion) scoreA += PIECE_VALUES[a.promotion];
                    if (b.promotion) scoreB += PIECE_VALUES[b.promotion];
                    return scoreB - scoreA;
                });

                for (const move of moves) {
                    this.game.move(move);
                    const value = -this.negamax(depth - 1, -Infinity, Infinity, -1);
                    this.game.undo();

                    if (value > bestValue) {
                        bestValue = value;
                        bestMove = move;
                    }
                }

                return bestMove;
            }

            negamax(depth, alpha, beta, color) {
                if (depth === 0 || this.game.game_over()) {
                    return color * this.evaluate();
                }

                const moves = this.game.moves({ verbose: true });

                // Move ordering
                moves.sort((a, b) => {
                    let scoreA = 0, scoreB = 0;
                    if (a.captured) scoreA += PIECE_VALUES[a.captured];
                    if (b.captured) scoreB += PIECE_VALUES[b.captured];
                    return scoreB - scoreA;
                });

                let maxValue = -Infinity;

                for (const move of moves) {
                    this.game.move(move);
                    const value = -this.negamax(depth - 1, -beta, -alpha, -color);
                    this.game.undo();

                    maxValue = Math.max(maxValue, value);
                    alpha = Math.max(alpha, value);

                    if (alpha >= beta) break;
                }

                return maxValue;
            }

            evaluate() {
                if (this.game.in_checkmate()) {
                    return this.game.turn() === 'w' ? -50000 : 50000;
                }
                if (this.game.in_draw()) {
                    return 0;
                }

                let score = 0;
                const board = this.game.board();

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const piece = board[row][col];
                        if (piece) {
                            const pieceValue = PIECE_VALUES[piece.type];
                            const pstValue = PST[piece.type][piece.color === 'w' ? row : 7 - row][col];
                            const totalValue = pieceValue + pstValue;

                            score += piece.color === 'w' ? -totalValue : totalValue;
                        }
                    }
                }

                // Mobility bonus
                const moves = this.game.moves().length;
                score += this.game.turn() === 'b' ? moves * 5 : -moves * 5;

                return score;
            }

            checkGameOver() {
                if (this.game.game_over()) {
                    let title, message;

                    if (this.game.in_checkmate()) {
                        if (this.game.turn() === 'w') {
                            title = 'You Lost';
                            message = 'Checkmate! Better luck next time.';
                        } else {
                            title = 'You Won!';
                            message = 'Checkmate! Congratulations!';
                        }
                    } else if (this.game.in_stalemate()) {
                        title = 'Draw';
                        message = 'Stalemate - no legal moves available.';
                    } else if (this.game.in_threefold_repetition()) {
                        title = 'Draw';
                        message = 'Draw by threefold repetition.';
                    } else if (this.game.insufficient_material()) {
                        title = 'Draw';
                        message = 'Draw by insufficient material.';
                    } else if (this.game.in_draw()) {
                        title = 'Draw';
                        message = 'Draw by fifty-move rule.';
                    }

                    document.getElementById('gameOverTitle').textContent = title;
                    document.getElementById('gameOverMessage').textContent = message;
                    document.getElementById('gameOverModal').classList.add('show');
                }
            }

            undoMove() {
                if (this.isThinking || this.moveHistory.length < 2) return;

                // Undo both player and computer move
                for (let i = 0; i < 2; i++) {
                    const move = this.game.undo();
                    if (move && move.captured) {
                        const arr = move.color === 'w' ? this.capturedPieces.white : this.capturedPieces.black;
                        arr.pop();
                    }
                    this.moveHistory.pop();
                }

                this.lastMove = this.moveHistory.length > 0
                    ? { from: this.moveHistory[this.moveHistory.length - 1].from, to: this.moveHistory[this.moveHistory.length - 1].to }
                    : null;

                this.clearSelection();
            }

            newGame() {
                this.game.reset();
                this.selectedSquare = null;
                this.possibleMoves = [];
                this.lastMove = null;
                this.moveHistory = [];
                this.capturedPieces = { white: [], black: [] };
                this.isThinking = false;
                document.getElementById('thinking').classList.remove('show');
                this.render();
            }

            updateStatus() {
                const status = document.getElementById('statusText');
                const whiteIndicator = document.getElementById('whiteIndicator');
                const blackIndicator = document.getElementById('blackIndicator');

                if (this.game.game_over()) {
                    status.textContent = 'Game over';
                    whiteIndicator.classList.remove('active');
                    blackIndicator.classList.remove('active');
                } else if (this.isThinking) {
                    status.textContent = '';
                    whiteIndicator.classList.remove('active');
                    blackIndicator.classList.add('active');
                } else {
                    status.textContent = this.game.turn() === 'w' ? 'Your turn' : 'Computer\'s turn';
                    whiteIndicator.classList.toggle('active', this.game.turn() === 'w');
                    blackIndicator.classList.toggle('active', this.game.turn() === 'b');
                }
            }

            render() {
                const board = this.game.board();
                const inCheck = this.game.in_check();
                const turn = this.game.turn();

                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        const file = String.fromCharCode(97 + col);
                        const rank = 8 - row;
                        const squareName = file + rank;
                        const square = document.querySelector(`[data-square="${squareName}"]`);
                        const piece = board[row][col];

                        // Reset classes
                        const isLight = (row + col) % 2 === 0;
                        square.className = `square ${isLight ? 'light' : 'dark'}`;

                        // Highlights
                        if (this.selectedSquare === squareName) {
                            square.classList.add('selected');
                        }
                        if (this.lastMove && (this.lastMove.from === squareName || this.lastMove.to === squareName)) {
                            square.classList.add('last-move');
                        }
                        if (inCheck && piece && piece.type === 'k' && piece.color === turn) {
                            square.classList.add('check');
                        }

                        // Possible moves
                        const possibleMove = this.possibleMoves.find(m => m.to === squareName);
                        if (possibleMove) {
                            if (piece) {
                                square.classList.add('possible-capture');
                            } else {
                                square.classList.add('possible-move');
                            }
                        }

                        // Render piece
                        let pieceEl = square.querySelector('.piece');
                        if (piece) {
                            if (!pieceEl) {
                                pieceEl = document.createElement('span');
                                pieceEl.className = 'piece';
                                square.appendChild(pieceEl);
                            }
                            const pieceChar = piece.color === 'w' ? piece.type.toUpperCase() : piece.type;
                            pieceEl.textContent = PIECES[pieceChar];
                        } else if (pieceEl) {
                            pieceEl.remove();
                        }
                    }
                }

                // Update captured pieces
                document.getElementById('whiteCaptured').textContent =
                    this.capturedPieces.white.map(p => PIECES[p]).join('');
                document.getElementById('blackCaptured').textContent =
                    this.capturedPieces.black.map(p => PIECES[p.toLowerCase()]).join('');

                this.updateStatus();
            }
        }

        // Initialize game
        const chessGame = new ChessGame();
    </script>
</body>
</html>
